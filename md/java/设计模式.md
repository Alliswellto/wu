# 设计模式

参考文献：https://www.jianshu.com/p/fc51be7e5bc0

​						 https://blog.csdn.net/A1342772/article/details/91349142

​						 http://c.biancheng.net/view/1361.html

# 一、创建型模式

## 1. 工厂模式

> 抽象工厂其实就是帮助减少系统的工厂数量的，但前提条件就是这些工厂要具备两个及以上的共性。工厂方法模式其实也是加强版的抽象工厂模式。

### 1.1 区别

+ 简单工厂其实就是一个超级工厂，他可以生产各种各样的产品，产品之间无关联。

+ 简单工厂可以理解为工厂方法的一种特例，将他的超级工厂拆分成多个工厂就是工厂方法。

+ 抽象工厂是前两种的补充，若使用了工厂方法，工厂提供的能力非常多，可以生产冰箱、电视、空调、洗衣机、电脑以及桌子等等，这样你就会产生很多的工厂。

  此时我们就可以通过分类，大大缩减系统中的工厂数量，前提是这些工厂需要在两个维度上具备共性(工厂方法是一个维度，优化的是另一个维度)。

### 1.2 简单工厂

我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {
            parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
            parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
            parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
            parser = new PropertiesRuleConfigParser();
        } else {
            throw new InvalidRuleConfigException(
                    "Rule config file format is not supported:" + ruleConfigFilePath);
        }
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }

    private String getFileExtension(String filePath) {
        //...解析文件名获取扩展名，比如rule.json，返回json
        return "json";
    }
}
```

为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParser parser = createParser(ruleConfigFileExtension);
        if (parser == null) {
            throw new InvalidRuleConfigException(
                    "Rule config file format is not supported:" + ruleConfigFilePath);
        }
        String configText = "";
//从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }

    private String getFileExtension(String filePath) {
//...解析文件名获取扩展名，比如rule.json，返回json
        return "json";
    }

    private IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
            parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
            parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
            parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
            parser = new PropertiesRuleConfigParser();
        }
        return parser;
    }
}
```

为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：

==第一种使用方式==

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfig
        if (parser == null) {
            throw new InvalidRuleConfigException(
                    "Rule config file format is not supported:" + ruleConfigFilePath);
        }
        String configText = "";
//从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }

    private String getFileExtension(String filePath) {
//...解析文件名获取扩展名，比如rule.json，返回json
        return "json";
    }
}

public class RuleConfigParserFactory {
    public static IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
            parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
            parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
            parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
            parser = new PropertiesRuleConfigParser();
        }
        return parser;
    }
}
```

在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我
们从缓存中取出 parser 对象直接使用。

==第二种使用方式==

```java
public class RuleConfigParserFactory {
    private static final Map<String, RuleConfigParser> cachedParsers = new HashMa

    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
        cachedParsers.put("properties", new PropertiesRuleConfigParser());
    }

    public static IRuleConfigParser createParser(String configFormat) {
        if (configFormat == null || configFormat.isEmpty()) {
            return null;//返回null还是IllegalArgumentException全凭你自己说了算
        }
        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
        return parser;
    }
}
```

### 1.3 工厂方法

简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加parser，也没有太多的 parser）是没有问题的。可以使用工厂方法模式解决。

```java
public interface IRuleConfigParserFactory {
    IRuleConfigParser createParser();
}

public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
        return new JsonRuleConfigParser();
    }
}

public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
        return new XmlRuleConfigParser();
    }
}

public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
        return new YamlRuleConfigParser();
    }
}

public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFact

        @Override
        public IRuleConfigParser createParser() {
            return new PropertiesRuleConfigParser();
        }
}
```

这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模
式比起简单工厂模式更加符合开闭原则。

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getPars
        if (parserFactory == null) {
            throw new InvalidRuleConfigException("Rule config file format is not supported:" + ruleConfigFilePath);
        }
        IRuleConfigParser parser = parserFactory.createParser();
        String configText = "";
//从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }

    private String getFileExtension(String filePath) {
//...解析文件名获取扩展名，比如rule.json，返回json
        return "json";
    }
}

//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { //工厂的工厂
    private static final Map<String, IRuleConfigParserFactory> cachedFactories =

    static {
        cachedFactories.put("json", new JsonRuleConfigParserFactory());
        cachedFactories.put("xml", new XmlRuleConfigParserFactory());
        cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
        cachedFactories.put("properties", new PropertiesRuleConfigParserFactory())
    }

    public static IRuleConfigParserFactory getParserFactory(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCa
        return parserFactory;
    }
}
```

当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添
加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。

当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。

### 1.4 抽象工厂

在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。

```txt
针对规则配置的解析器：基于接口IRuleConfigParser
JsonRuleConfigParser
XmlRuleConfigParser
YamlRuleConfigParser
PropertiesRuleConfigParser
针对系统配置的解析器：基于接口ISystemConfigParser
JsonSystemConfigParser
XmlSystemConfigParser
YamlSystemConfigParser
PropertiesSystemConfigParser
```

针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。

```java
public interface IConfigParserFactory {
    IRuleConfigParser createRuleParser();

    ISystemConfigParser createSystemParser();
//此处可以扩展新的parser类型，比如IBizConfigParser
}

public class JsonConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
        return new JsonRuleConfigParser();
    }

    @Override
    public ISystemConfigParser createSystemParser() {
        return new JsonSystemConfigParser();
    }
}

public class XmlConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
        return new XmlRuleConfigParser();
    }

    @Override
    public ISystemConfigParser createSystemParser() {
        return new XmlSystemConfigParser();
    }
}
// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码
```

### 1.5 适用场景

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- 代码复用： 创建代码抽离到独立的工厂类之后可以复用。
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

## 2. 单例模式

### 2.1 概述

一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

进程唯一。

对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader）。单例类对象的唯一性前提也必须保证该类被同一个类加载器加载！

### 2.2 实现方式

#### 2.2.1 饿汉式

饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例）。

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private static final IdGenerator instance = new IdGenerator();
    
    private IdGenerator() {}
    
    public static IdGenerator getInstance() {
    	return instance;
    }
    
    public long getId() {
    	return id.incrementAndGet();
    }
}
```

#### 2.2.2 懒汉式

支持延迟加载

```java
public class IdGenerator {
private AtomicLong id = new AtomicLong(0);
private static IdGenerator instance;
    
private IdGenerator() {}

    public static synchronized IdGenerator getInstance() {
        if (instance == null) {
            instance = new IdGenerator();
        }
        return instance;
	}
    
    public long getId() {
        return id.incrementAndGet();
    }
}
```

懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。

#### 2.2.3 双重检测

饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。
在这种实现方式中，只要 instance 被创建之后，即便再调用getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static IdGenerator instance;
    
	private IdGenerator() {}
    
    public static IdGenerator getInstance() {
        if (instance == null) {
        	synchronized(IdGenerator.class) { // 此处为类级别的锁
       			if (instance == null) {
        			instance = new IdGenerator();
        		}
        	}
   		}
    	return instance;
    }
    
    public long getId() {
    	return id.incrementAndGet();
    }
}
```

因为指令重排序，可能会导致 IdGenerator 对象被
new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。
		  要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。

#### 2.2.4 静态内部类

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    
    private IdGenerator() {}
    
    private static class SingletonHolder{
    	private static final IdGenerator instance = new IdGenerator();
    }
    
    public static IdGenerator getInstance() {
    	return SingletonHolder.instance;
    }
    public long getId() {
    	return id.incrementAndGet();
    }
}
```

SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由
JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。

#### 2.2.5 枚举

```java
public enum IdGenerator {
    INSTANCE;
    private AtomicLong id = new AtomicLong(0);
   
    public long getId() {
    	return id.incrementAndGet();
    }
}
```

#### 2.2.6 线程唯一

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private static final ConcurrentHashMap<Long, IdGenerator> instances = new ConcurrentHashMap<>();
    private IdGenerator() {}
    public static IdGenerator getInstance() {
        Long currentThreadId = Thread.currentThread().getId();
        instances.putIfAbsent(currentThreadId, new IdGenerator());
        return instances.get(currentThreadId);
    }
    
    public long getId() {
    	return id.incrementAndGet();
    }
}
```



### 2.3 问题

- 单例对 OOP 特性的支持不友好

- 单例会隐藏类之间的依赖关系

- 单例对代码的扩展性不友好

  若业务之后需要创建两个实例

- 单例对代码的可测试性不友好

  可以把单例模块放到一个方法中，再进行测试

- 单例不支持有参数的构造函数

## 3. 

# 二、结构型模式

## 1.  适配器模式

### 1.1 概述

> 适配器模式是一种结构型模式，他能使接口不兼容的对象相互合作。适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。

### 1.2 优缺点

==优点==

+ 客户端通过适配器可以透明地调用目标接口。
+ 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
+ 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
+ 在很多业务场景中符合开闭原则

==缺点==

+ 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
+ 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。

### 1.3 类适配器

![image-20220725113943129](../../Image\image-20220725113943129.png)

```java
public class ClazzAdaptMode {

    /**
     * 类适配器模式
     * TODO: 当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配者模式，创建一个新类，继承原有的类，实现新的接口即可。
     * 通过多重继承目标接口和被适配者类的方式来实现适配
     * @param args
     */
    public static void main(String[] args) {
        Target target = new Adapter();
        target.process();
    }
}

interface Target {
    void process();
}

class Item {
    void doIt() {
        System.out.println("do do do...");
    }
}

class Adapter extends Item implements Target {

    @Override
    public void process() {
        super.doIt();
    }
}
```

### 1.4 对象适配器

![image-20220725113952319](../../Image\image-20220725113952319.png)

```java
/**
 * @Description: ObjectAdaptModel
 * TODO: 将一个类的接口转换成用户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
 * @Author yanwu
 * @Date 2022/7/21 20:34
 * @Version 1.0
 */
public class ObjectAdaptModel {

    public static void main(String[] args) throws InterruptedException {
        Task<Long> task = new Task<Long>(100L);
        Thread thread = new Thread(new RunnableAdapt<Long>(task));
        thread.start();
        thread.join();
    }
}

/**
 * 对象适配器模式
 * TODO: 当希望将一个对象转换成满足另一个新街口的对象时，可以创建一个 Wrapper 类，持有原类的一个实例，在 Wrapper 的方法中，调用实例的方法即可
 * 使用组合实现，在适配器中包含被适配器的对象，然后调用其方法
 * @param <T>
 */
class RunnableAdapt<T> implements Runnable {

    private Callable<T> callable;

    public RunnableAdapt(Callable<T> callable) {
        this.callable = callable;
    }

    @Override
    public void run() {
        try {
            callable.call();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

class Task<T> implements Callable<Long> {

    private final Long num;

    Task(Long num) {
        this.num = num;
    }

    @Override
    public Long call() throws Exception {
        long r = 0;
        for (long i = 1L; i <= this.num; i++) {
             r += i;
        }
        System.out.println(r);
        return r;
    }
}
```

### 1.5 接口适配器

```java
public class InterfaceAdaptModel {

    public static void main(String[] args) {
        AdapterImpl target = new AdapterImpl();
        target.doIt();
    }
}

interface Target {

    void a();

    void b();

    void process();
}

/**
 * 接口适配器模式
 * TODO: 当不希望实现一个接口中的所有方法时，可以创建一个抽象类实现所有方法，我们写别的类时，继承抽象方法即可
 */
abstract class Adapter implements Target {
    @Override
    public void a() {

    }

    @Override
    public void b() {

    }

    @Override
    public void process() {
        System.out.println("do do do...");
    }
}

class AdapterImpl extends Adapter {

    public void doIt() {
        super.process();
    }
}
```

### 1.6 双向适配器

```java
public class DoubleAdapter {

    public static void main(String[] args) {
        Target target = new TargetRealize();
        Adapter adapter = new AdapterRealize();
        Adaptee adaptee = new Adaptee(target);
        adaptee.doIt();

        Adaptee adaptee1 = new Adaptee(adapter);
        adaptee1.process();
    }
}

interface Target {
    void process();
}

interface Adapter {
    void doIt();
}

class TargetRealize implements Target {

    @Override
    public void process() {
        System.out.println("target...");
    }
}

class AdapterRealize implements Adapter {

    @Override
    public void doIt() {
        System.out.println("adapter...");
    }
}

class Adaptee implements Target, Adapter {

    private Target target;
    private Adapter adapter;

    public Adaptee(Target target) {
        this.target = target;
    }

    public Adaptee(Adapter adapter) {
        this.adapter = adapter;
    }

    @Override
    public void process() {
        adapter.doIt();
    }

    @Override
    public void doIt() {
        target.process();
    }
}
```

```text
类适配器，以类给到，在Adapter里，就是将src当做类，继承，
对象适配器，以对象给到，在Adapter里，将src作为一个对象，持有。
接口适配器，以接口给到，在Adapter里，将src作为一个接口，实现。

使用原则: 根据合成复用原则，组合大于继承。因此，类适配器模式应该少用
```

### 1.7 适用场景

1.  当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类。
2.  如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。

### 1.8 与其他模式的关系

1. [桥接模式](https://refactoringguru.cn/design-patterns/bridge)通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面，适配器模式](https://refactoringguru.cn/design-patterns/adapter)通常在已有程序中使用， 让相互不兼容的类能很好地合作。
2. [适配器](https://refactoringguru.cn/design-patterns/adapter)可以对已有对象的接口进行修改，装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合，适配器则无法实现。
3. [适配器](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口，代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口，装饰](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。
4. [外观模式](https://refactoringguru.cn/design-patterns/facade)为现有对象定义了一个新接口，适配器](https://refactoringguru.cn/design-patterns/adapter)则会试图运用已有的接口。 *适配器*通常只封装一个对象， *外观*通常会作用于整个对象子系统上。
5. [桥接](https://refactoringguru.cn/design-patterns/bridge)、[状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy)（在某种程度上包括[适配器](https://refactoringguru.cn/design-patterns/adapter)）模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

## 2.

# 三、行为型模式

## 1. 责任链模式

https://www.cnblogs.com/xrq730/p/10633761.html

### 1.1 概述

> 为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，知道有对象处理它为止。

### 1.2 优缺点

```txt
在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。
```

==优点==

+ 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
+ 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
+ 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
+ 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
+ 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

==缺点==

+ 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
+ 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
+ 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

### 1.3 实现

![image-20220725205042246](../../Image\image-20220725205042246.png)

```java
public class HandlerChainModel {

    public static void main(String[] args) {
//        FirstHandler first = new FirstHandler();
//        SecondHandler second = new SecondHandler();
//        ThirdHandler third = new ThirdHandler();

        AbstractHandler link = AbstractHandler.link(new FirstHandler(), new SecondHandler(), new ThirdHandler());
        link.doHandler(new Request("zs", 1000));
        link.doHandler(new Request("ls", 900));
        link.doHandler(new Request("ww", 4000));

//        first.setNext(second);
//        second.setNext(third);

//        first.doHandler(new Request("zs", 1000));
//        first.doHandler(new Request("ls", 900));
//        first.doHandler(new Request("ww", 4000));
    }
}

@Data
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
class Request {

    /**
     * 姓名
     */
    private String name;

    /**
     * 报销金额
     */
    private Integer amount;
}

/**
 * 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。
 * 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
 */
interface Handler {

    /**
     * 处理请求
     * @param request
     * @return
     */
    Boolean doHandler(Request request);
}

@Setter
class FirstHandler extends AbstractHandler {

//    private Handler next;

    @Override
    public boolean doHandler(Request request) {
        if (request.getAmount() < 1000) {
            System.out.println("first success!");
            return true;
        }
//        return next.doHandler(request);
        return checkNext(request);
    }
}

@Setter
class SecondHandler extends AbstractHandler {

//    private Handler next;

    @Override
    public boolean doHandler(Request request) {
        if (request.getAmount() >= 1000 && request.getAmount() < 3000) {
            System.out.println("second success!");
            return true;
        }
        return checkNext(request);
//        return next.doHandler(request);
    }
}

@Setter
class ThirdHandler extends AbstractHandler {

//    private Handler next;

    @Override
    public boolean doHandler(Request request) {
        System.out.println("third success!");
        return true;
    }
}

/**
 * Servlet 写法
 */
class HandlerChain implements Handler {

    List<Handler> handlerChain;
    Integer pos = 0;
    Request request;

    public void addHandler(Handler handler) {
        if (handlerChain.isEmpty()) {
            handlerChain = new ArrayList<>();
        }
        handlerChain.add(handler);
    }

    @Override
    public Boolean doHandler(Request request) {
        if (pos == handlerChain.size()) {
            System.out.println("success!");
        }
        return handlerChain.get(pos ++).doHandler(request);
    }
}

abstract class AbstractHandler {
    private AbstractHandler next;

    public static AbstractHandler link(AbstractHandler first, AbstractHandler... handlers) {
        AbstractHandler head = first;
        for (AbstractHandler handler : handlers) {
            head.next = handler;
            head = handler;
        }
        return first;
    }

    public abstract boolean doHandler(Request request);

    protected boolean checkNext(Request request) {
        if (next == null) {
            return true;
        }
        return next.doHandler(request);
    }
}
```

### 1.4 适用场景

1. 当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式。

   该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。

2. 当必须按顺序执行多个处理者时，可以使用。

   无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。

3. 如果所需处理者及其顺序必须在运行时进行改变，可以使用。

   如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。

### 1.5 与其他模式的关系

1. [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)、[命令模式](https://refactoringguru.cn/design-patterns/command)、[中介者模式](https://refactoringguru.cn/design-patterns/mediator)和[观察者模式](https://refactoringguru.cn/design-patterns/observer)用于处理请求发送者和接收者之间的不同连接方式：

   - 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
   - 命令在发送者和请求者之间建立单向连接。
   - 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
   - 观察者允许接收者动态地订阅或取消接收请求。

2. [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)通常和[组合模式](https://refactoringguru.cn/design-patterns/composite)结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。

3. [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可使用[命令模式](https://refactoringguru.cn/design-patterns/command)实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。

   还有另外一种实现方式， 那就是请求自身就是一个*命令*对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。

4. [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。

   [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外，装饰无法中断请求的传递。

## 2.